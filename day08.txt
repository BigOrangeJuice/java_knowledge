java_day08
2021/7/23

1.this关键字：

	* 位置：实例方法和构造方法当中，不能出现在静态方法中

	* 本质是个引用(即变量)

	* 伴对象而生，创建100个对象，里面便含100个this

	* this可以出现在"实例方法"中，this指向当前正在指向这个动作的对象

	* 多数情况可以省略

		public void setAge(int age){
			this.age = age ;
		}

		前面的age是实例变量，后面的age是局部变量；如果不加this，java会选择就近原则，两个一样的局部变量在做无意义的赋值

		—— 因此，用于区分实例变量和局部变量时，this不可省略

	* this不能在static修饰的方法中使用

	* 避免代码重复的办法：通过this()调用其他的构造方法，且不会创建新的对象

	* 用途：1>用在实例方法当中，代表当前对象【语法：this.】

		2>用在构造方法当中，通过当前构造方法调用其他构造方法【语法：this(实参)】【注意：必须写在构造方法的首行，前面不得写代码！！！】

2.没有static修饰的变量叫实例变量，没有static修饰的方法叫实例方法，他们在执行的过程中都需要对象的参与

	* 在static修饰的方法中，不能“直接”访问实例变量和实例方法【因为两者都需要对象的存在，因此需要先创建变量再访问】

		而static修饰的方法中，是不存在this的，也就是说当前对象是不存在的

3.static:

	* static修饰的变量为静态变量，其在类加载时就会初始化，无需创建对象便开辟了内存空间，因为它存放在方法区内存
	
		【区别于实例变量】【区别于c的存放于堆区的静态变量】

	* 对于每个属性都有且不会改变的，应用static修饰，也可节省空间

	* 访问：类名.	or 引用.	,建议使用前者

	* 采用引用.的方式访问时，即便对象是null，也不会出现空指针异常，因为访问静态变量的数据不需要对象的存在

	* static修饰的东西都是类级别的，都存放在方法区；而对象级别的存放在堆区

	* static修饰方法：静态方法又称【静态上下文】

		方法描述动作，当所有的对象执行这个动作时，最终产生的影响都是一样的，那么这个动作已经不再属于某个对象动作，可以将这个动作提升为类级别动作

	* 静态代码块：写在方法外

		—— 无需依赖main方法主入口也可运行

		—— 语法结构：static{
				java语句 ;
				}

		—— 静态代码块在类加载时执行一次，且仅这一次

		—— 在一个类中可编写多个，且遵守自上而下的执行顺序【不过没必要】

		—— 作用：

			* 与具体需求有关,例如项目中要求在类加载的时刻执行代码完成日志的记录

			  那么这段记录日志的代码就可以编写到静态代码块中，完成日志记录

			* 静态代码块是java为程序员准备一个特殊的时刻，其成为类加载时刻

			* 通常在静态代码块当中完成预备工作，先完成数据的准备工具，例如：初始化连接池、解析XML配置文件......

4.实例代码块：

	* 语法结构：{
			java语句 ;
			}

	* 执行时间：在构造方法执行之前执行

	* 也是一个特殊的时刻 —— 对象初始化时机

5.大多数方法都定义为实例方法，一般一个行为或一个动作在发生的时候，都需要对象的参与。
  
  但也有例外，如"工具类"大多都是静态方法，因为工具类就是方便编程，为了方便方法的调用，自然最好不需要new对象

6.继承：子类 extends 父类
	
	* 说来了，父类里的东西，子类也能用，调用子类时也可以使用父类

	* 基本作用：代码复用

	* 重要作用：方法覆盖和多态机制

	* 语法结构：[修饰符列表] class 类型 extends 父类名{
			类体 = 属性和方法	
			}

	* java语言中的继承只支持单继承，一个类不能继承很多类，只能继承一个类

	* 术语：
		
		B类继承A类，其中：

			A类称为：父类、基类、超类、superclass

			B类陈为：子类、派生类、subclass

	* 在java语言中子类继承父类的数据：

		—— 私有方法不支持继承

		—— 构造方法不支持继承

		—— 其他数据都可以继承

	* 虽然java语言只支持单继承，但一个类可以间接继承其他类：

		C extends B{}
		B extends A{}
		A extends T{}

		C类直接继承B类，但又间接继承A类和T类

7.方法覆盖：又称方法重写(override/overwrite)

	* 适用前提：当父类的方法已经无法满足当前子类的业务需求，子类有必要将父类中继承过来的部分方法进行重新编写

	* 满足条件：
		
		1>发生在具有继承关系的父子类之间

		2>返回值类型、方法名、形参列表都相同

		3>访问权限只能更高，不能更低(public > protected > private)

		4>抛出异常不能更多，可以更少【暂不解释】

	* 尽可能复制粘贴地改，不易出错

	* 注意：

		1>私有方法不能继承，所以不能覆盖

		2>构造方法不能继承，所以不能覆盖

		3>静态方法不存在继承，所以不能覆盖

		4>覆盖只针对方法，不谈属性

