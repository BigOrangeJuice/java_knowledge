java_day20
2021/8/6

1.List接口：

	—— List集合存储元素的特点：

		* 有序：List集合的元素有自己的下标

		* 可重复：存储一个元素后，可再次存储一个相同的元素

	—— List中特有的常用方法：
 
		* void		add(int index, E element) - 在列表的指定位置插入指定元素

			使用较少，因为需要移动元素，效率较低
	
		* Object	get(int index) - 返回列表中指定位置的元素

		* Object	set(int index, E element) - 用指定元素替换列表中指定位置的元素【并且返回替代后的元素】

		* Object	remove(int index) - 移除列表中指定位置的元素【并且会返回删之前所在位置的元素】

		* int		indexOf(Object o) - 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1

		* int		lastIndexOf(Object o) - 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1

	—— List集合独有的遍历方式：通过下标遍历

		for(int i = 0;i < myList.size();++ i){
			sout(myList.get(i)) ;
		}

2.ArrayList类：

	—— ArrayList集合初始化容量是10【可以手动进行初始化扩容】

	—— 容量不够时自动扩容：原容量的1.5倍【建议提前手动初始化扩容，提升效率】

	—— 优点：1>检索效率高

		 2>向数组末尾增加元素，效率较高

	—— 缺点：1>对数组进行增删改元素，效率较低

3.链表：

	—— 节点 - 链表中最基本的单元

		每个节点Node都有两个属性：一个是存储的数据，另一个是下一个节点的内存地址

	—— 优点：由于链表上的元素在空间存储上内存地址不连续，所以随机增删改集合内的元素不会有大量元素位移，所以效率较高

	—— 缺点：检索/查找元素的效率较低【每次查找某个元素都需要从头结点开始往下遍历】

	—— 单双向链表的区别：单向链表中，一个节点只有下一个节点的地址；
	
				而双向链表中，一个节点有前后两个节点的地址【双向，两个节点相互指向】

4.向量Vector：

	—— 默认初始化容量是10【自动扩容会扩大为原容量的2倍】

	—— Vector中的所有方法都是线程同步的，由synchronize修饰，效率较低

5.ArrayList转为Vector：

	—— 调用Collections中的静态方法synchronizeList：Collections.synchronizeList(ArrayList类的数组)

6.泛型：

	—— 只在程序编译阶段起作用，作用给编译器

	—— 格式：
	
		定义：List<数据类型> 变量名 = new ArrayList<同一个数据类型>() ;

		迭代器：Iterator<同一个数据类型>iterator = 变量名.iterator() ;

		这样也避免不了需要向下转型

	—— 优点：集合中存储的元素类型统一

		从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”

	—— 缺点：导致集合中存储的元素缺乏多样性

7.自动类型推断机制：钻石表达式

	—— 格式：List<数据类型> 变量名 = new ArrayList<>() ;

8.增强for循环：foreach

	—— 格式：for(数据类型 变量名 : 数组或集合){
			sout(变量名) ;
		}

	—— 缺点：无下标

